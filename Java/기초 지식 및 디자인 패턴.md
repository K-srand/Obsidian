
# Table of contents

1. JVM(Java Virtual Machine)
: 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것

- 자동적인 메모리 관리(GC)를 수행하며 스택(Stack) 기반의 가상 머신
- .java 파일 -> .class 파일

JVM으로 인해서 이식성이 좋기 때문에 java를 많이 사용함.


2. 객체지향 프로그래밍 OOP(Object Oriented Programming)
: 프로그래밍에서 필요한 데이터를 추상화시켜 행위(Method)와 상태(Attribute)를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

- 현실 세계를 프로그램 설계에 반영한다는 개념을 기반으로 함.
- OOP의 4가지 특징으로 캡슐화, 추상화, 다형성, 상속(캡추다상)이 있음.

캡슐화 : 메소드간의 중첩을 막아서(public, private, defalt, protected) 서비스 간의 접근 허용을 조절할 수 있음. → 정보은닉

추상화 : abstract class 추상 클래스 → 일반 클래스와는 다르게 객체 생성이 안됨.

다형성 : 한 가지 틀을 만들고서 세부적인 내용은 구현체에서 구현

상속 : 상위 개념을 하위 개념으로 물려 받는 것

object class : 모든 클래스의 부모 클래스(최상위)

![](https://separated-list-55b.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F324d172c-ef31-41e4-9e08-e799682abe58%2F70412913-7826-4b45-8082-2c41eae52d77%2Fimage.png?table=block&id=1beb9f90-608d-41f5-9437-b7773bcd88b4&spaceId=324d172c-ef31-41e4-9e08-e799682abe58&width=1420&userId=&cache=v2)


3. 가속수명시험 ALT(Accelerated Life Testing)
: 사용 조건보다 가혹한 조건을 부과함으로써 고장 메커니즘을 촉진, 고장 데이터를 빨리 얻어 그 데이터로부터 정상 조건에서의 수명 예측

내구성, 신뢰성, 안정성


4. 가비지 컬렉션, 컬렉터(GC Garbage Collection)
: 메모리 관리 방법 중 하나로 메모리 영역에서 사용하지 않는 객체(인스턴스)들을 제거하는 작업을 의미

- JVM에서 동작
- Java는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기에 객체를 사용하고 제거하는 기능이 필요함

![](https://separated-list-55b.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F324d172c-ef31-41e4-9e08-e799682abe58%2F4a64eabd-8783-4ae4-a3c7-f03f79c3b445%2Fimage.png?table=block&id=0d2dbdd2-8100-4203-a554-a645b7428d33&spaceId=324d172c-ef31-41e4-9e08-e799682abe58&width=1360&userId=&cache=v2)


- 가비지 컬렉션 과정
GC의 작업을 수행하기 위해 JVM이 애플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거(Mark and Sweep 과정)하고 작업이 재개됨.


5. 오버 라이딩과 오버 로딩
오버 라이딩(Overriding) : 상위 클래스의 메서드를 재정의 / 런타임 다형성

오버 로딩(Overloading) : 같은 클래스 내에서 동일한 메서드 이름을 가지지만, 매개 변수의 타입 혹은 개수가 다르게 구현할 수 있는 것을 의미 / 컴파일 타임 다형성

- "@Override" 어노테이션을 써야 하는 이유는 컴파일 타임에 오버 라이딩에 대한 안정성을 부여해주기 때문.
- 런타임 : 프로그램이 실행되는 환경
- 컴파일 : 자연어 -> 기계어

  
6. 자바 리플렉션(Reflection)
: 힙 영역에 로드된 클래스 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있도록 지원하고, 인스턴스의 필드와 메소드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API

- 구체적인 클래스 타입을 알지 못해도 클래스의 메서드, 타입, 변수들을 접근할 수 있게 해주는 Java API
- 컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법이라 할 수 있다.
- JVM에서 실행되는 애플리케이션의 런타임 동작을 검사하거나 수정할 수 있는 기능이 필요한 프로그램에서 사용됨.
- 구체적인 클래스를 알지 못해도 동적으로 클래스를 만들어서 의존 관계를 맺어줄 수 있다.
- 개발 규모가 큰 스프링인 경우, 리플렉션을 이용한 Dynamic proxy를 통해서 @AutoWired, @Service

리플렉션 사용 사례
코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용

프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능 제공
intelliJ의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있음.


7. 제네릭(Generics)
: Java의 타입 안정성을 맡고 있음.

- <>안에 타입 지정
- 컴파일 과정에서 타입 체크를 해주는 기능으로 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형 변환의 번거로움을 줄여줌.

제네릭(Generic)은 직역하자면 '일반적인'이라는 뜻이다. 조금 더 부연설명을 하자면 '데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법'이다.

우리가 흔히 쓰는 ArrayList, LinkedList 등을 생성할 때 어떻게 쓰는가?
객체<타입> 객체명 = new 객체<타입>(); 이렇게 쓰지 않는가? 
즉, 아래와 같이 여러 생성방식이 있다.

꺽쇠 괄호 안에 타입을 지정 이렇듯 제네릭(Generic)은 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다. 한마디로 특정(Specific) 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반(Generic) 타입이라는 것이다.


8. Java의 접근 제어자
: 변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미
총 4 가지 종류가 있음 .

- public - 접근 제한이 없음. (같은 프로젝트 내 어디서든 사용 가능)
- protected - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능
- default - 해당 패키지 내에서만 접근 가능
- private - 해당 클래스에서만 접근 가능

![](https://separated-list-55b.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F324d172c-ef31-41e4-9e08-e799682abe58%2Fa91cb2a8-09c2-45ad-aaa8-282417b58dea%2Fimage.png?table=block&id=c53d772d-219f-49a1-830b-8c67b6a528c0&spaceId=324d172c-ef31-41e4-9e08-e799682abe58&width=1420&userId=&cache=v2)



9. 클래스와 객체
클래스(Class) : 객체를 정의하는 틀 또는 설계도와 같은 의미, 객체를 생성하는 데 사용

객체(Object) : 클래스를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 가짐.

 - 상태는 필드(fields), 행동은 메소드(Method)라고 표현하고, 객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라 부름.
 - 사실상 java에서는 객체와 인스턴스가 같은 맥락


10. SOLID(객체 지향 5대 원칙)
: 객체 지향 프로그래밍에서 유지보수성과 확장성을 높이기 위한 다섯 가지 설계 원칙

- SRP(단일 책임 원칙) : 1개의 클래스는 1개의 책임만 가져야 한다.
- OCP(개방-폐쇄 원칙) : 확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 한다.
- ISP(인터페이스 분리 원칙) : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 되는 원칙 / 즉. 거대한 인터페이스보단 더 작고 구체적인 인터에 피스로 분리해야 한다.
- DIP(의존관계 역전 원칙) - 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙 / 구체적으로는 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙이다.


11. 인터페이스와 추상 클래스
추상 클래스 : 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용하고, 단일 상속만 가능하다. 그리고 추상 클래스를 상속하는 집합 간에는 연관 관계가 있다. (class는 일회용)

인터페이스 : 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하고, 다중 상속이 가능하다. 인터페이스를 구현하는 집합 간에는 관계가 없을 수 있다.

![](https://separated-list-55b.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F324d172c-ef31-41e4-9e08-e799682abe58%2Feb9f4ff8-ce6c-448a-8f5c-e98c2dbc39ef%2Fimage.png?table=block&id=93d2c969-7b1d-4354-ac92-c667dd6f8eb1&spaceId=324d172c-ef31-41e4-9e08-e799682abe58&width=1420&userId=&cache=v2)


12. 컬렉션 프레임워크(Java Collection Framework)
: 자료 구조를 바탕으로 객체, 데이터들을 효율적으로 관리할 수 있는 자료 구조들이 있는 라이브러리

- 자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue 인터페이스도 존재한다.

List와 Set, Map의 차이점은?

List는 순서가 있는 데이터의 집합이며, 데이터의 중복을 허용합니다. 대표적인 구현체로는 ArrayList가 있고, 이는 Vector를 개선한 것입니다. 이외에도 LinkedList 등의 구현체가 있습니다.

Vector, ArrayList, LinkedList, Stack, Queue

Set은 순서가 없는 데이터의 집합이며, 데이터의 중복을 허용하지 않습니다. 대표적인 구현체로는 HashSet이 있고, 순서를 보장하기 위해서는 LinkedHashSet을 사용합니다. (Map의 key-value 구조에서 key 대신 value가 들어가 value를 key로 하는 자료구조)

HashSet, LinkedHashSet, TreeSet

Map은 키와 값이 한 쌍으로 이뤄져 있고, 키를 기준으로 중복을 허용하지 않으며, 순서가 없습니다. key의 순서를 보장하기 위해서는 LinkedHashMap을 사용합니다.

HashMap, TreeMap, HashTable, Properties


13. 직렬화(Serialize)란?

Java에서 입출력할 때는 스트림이라는 데이터 통로를 통해 이동한다.

하지만 객체는 그렇지 않아서 스트림을 통해 전송이 불가능해서 객체를 스트림으로 입출력하기 위해 바이트 배열로 변환하는 것을 의미함

역 직렬화 : 스트림 -> 객체


14. 정적(static) 이란?

런을 돌리면 메모리 단에 할당이 됨.

static는 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메서드 메모리 영역에 적재할 때 클래스 별로 관리된다.

static 키워드를 통해 생성된 정적 멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있다.

But, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료 시까지 메모리가 할당된 채로 존재해서, 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있다.


15. 멀티 스레드(Multi Thread)
프로세스 : OS로부터 자원을 할당 받은 상태

스레드 : 프로세스 내에서 실행되는 여러 흐름의 단위

멀티 스레드란 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것

멀티 스레드 프로그램은 공유하는 자원에 대해 동기화 문제가 발생할 수 있다.

method area, heap area는 스레드가 공유하는 영역이다.

@ 추가적으로 JS(자바스크립트)는 싱글 스레드

멀티 스레드(Multi Thread) 사용 이유는?

멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유하므로, 시스템 자원의 낭비가 적다.

하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있어 사용자와의 응답성도 좋아진다.


16. Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나?

정수형 byte, short, int, long 실수형 float, double 문자형 char 논리형 boolean이 있고,

정수형 1, 2, 4, 8, 실수형 4, 8, 문자형 2, 논리형 1 바이트를 차지한다.


17. 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명하라.
: 객체 생성 이후 내부의 상태가 변하지 않는 객체

- read-only 메소드만을 제공하며, 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사(defensive-copy)를 통해 제공한다.

Java의 대표적인 불변 객체로는 String, Integer, boolean이 있다.

불변 객체를 사용하면 java 코드의 안정성과 동시성, 유지관리가 더 쉬워진다. 코드의 품질과 성능을 향상하려면 가능한 한 자주 사용하는 것이 좋다.

불변 객체나 final을 굳이 사용해야 하는 이유는?

불변 객체나 final 키워드를 사용해 얻는 이점은 다음과 같습니다.

- Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다. 
(공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)

- 실패 원자적인 메소드를 만들 수 있다. (어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)

- 부수효과를 피해 오류를 최소화 할 수 있다. 
※ 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상

- 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.

- 가비지 컬렉션 성능을 높일 수 있다. 
  (가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)


18. 싱글톤 패턴에 대해 설명하라.

단 하나의 인스턴스 객체를 생성해서 단일성을 보장한다(메모리 낭비 방지)

싱글톤 패턴의 대표적인 예시 간단하게

싱글톤 패턴의 대표적인 예시는 Spring Bean 입니다.

스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다.


19. 자바의 메모리 영역
: 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당

- 메소드(Method) 영역 : 전역변수와 static변수를 저장하며, Method 영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.

- 스택(Stack) 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.

- 힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

각 메모리 영역이 할당되는 시점은 언제인가?

- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성

- Stack 영역 : 메소드가 호출될 때 할당

- Heap 영역 : 런타임시 할당


20. 생성자
: 클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드입니다.

명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다.


21. inner Class(내부 클래스)의 장점에 대해 설명하라.

내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.

서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.

외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다.


22. Error와 Exception의 차이는?

Error는 실행 중 일어날 수 있는 치명적 오류를 말합니다. 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속합니다.

반면, Exception은 Error보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있습니다


23. Optional API에 대해 설명해주세요.

개발할 때 가장 많이 발생하는 예외 중 하나가 NPE(NullPointerException)입니다.NPE를 피하려면 null 여부 검사를 필연적으로 하게 되는데 만약 null 검사를 해야하는 변수가 많은 경우 코드가 복잡해지고 번거롭습니다. 하지만 Java8 부터 Optional<T>을 제공하여 null로 인한 예외가 발생하지 않도록 도와주고, Optional 클래스의 메소드를 통해 null을 컨트롤 할 수 있습니다.


24. AOP(Aspect-Oriented Programming)란?
: 프로그램의 핵심 기능에서 부가적인 관심사(로깅(로그인, 회원 가입 등), 보안, 트랜잭션 관리 등)를 분리하여 모듈화하는 프로그래밍 기법입니다. 이를 통해 코드 중복을 줄이고 관심사의 분리를 효과적으로 구현할 수 있습니다.

25. 파이썬과 자바
데이터 과학, 머신러닝, 빠른 프로토타입 개발이 필요한 경우, Python의 간결한 문법과 다양한 라이브러리가 더 유리할 수 있다고 생각.
대규모 엔터프라이즈급 애플리케이션이나 고성능 서버 개발이 필요한 경우, 자바의 강력한 성능과 멀티스레딩 기능이 더 적합하지 않나 생각.

26. 멀티스레딩
: 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상(스레드 곧 작업자가 몇 명인지에 관한 것)
여러 다른 함수들을 동시 실행됨.
*스레드 : 프로세스 내에서 실행되는 흐름의 단위

27. 비동기
: 여러 task가 동시 발생. 메서드의 실행 흐름 막지 않음. 함수 끝났을 때 실행결과에 접근(task에 관한 것)
여러함수들이 non-blocking으로 실행됨.

28. 동기
: 일(task)가 들어온 순서대로 처리

29. 동일성/동등성
- 동일성 : 객체의 참조가 같은가?
- 동등성 : 객체는 다를 수 있으나 논리적인 값이 같은가?
  
  필요한 경우만 equals를 재정의해서 사용하면 된다.

30. OCP 원칙
- Open : 새로운 클래스를 추가하고, toString()을 오버라이딩해서 기능 확장 가능.
- Closed : 새로운 클래스를 추가해도 Object와 toString()을 사용하는 클라이언트 코드 ObjectPrinter는 변경하지 않아도 됨.



