==10번 4번 X== -> 1번
인조식별자를 사용하면 불필요하게 발생하는 중복데이터를 막을 수 있다. X
->  중복 데이터의 발생 가능성을 높이기 때문에 데이터 품질의 저하를 발생시킬 수 있는 단점을 가짐.

==11번 2번 X== -> 3번
FROM절에서 테이블 별칭을 선언한 경우는 반드시 테이블 별칭만으로 컬럼을 구분해야함.(또는 생략)
-> TABLE1.COL2는 잘못된 표현.

==12번 1번 X== -> 4번
실행 순서 : from > where > group by > having > select > order by

==14번 2번 X== -> 4번
||(연결연산자)는 ORACLE에서의 문자열 결합 방식
SQL Server에서는 +를 사용하여 문자열을 결합 할 수 있음.
& 연산자로 문자열 결합은 불가.

==16번 3번 X== -> 1번
주민번호의 앞 6자리를 사용하여 날짜변환 시 RR 포맷을 사용하면 두 자리 연도가 1~49 사이면 2000년대, 50~99이면 1900년도의 4자리 연도로 출력
YY를 사용하면 2000년대를 출력

==20번 4번 X== -> 2번
NOT IN문의 서브쿼리 결과 중 NULL이 포함되는 경우 데이터가 출력되지 않음.
NULL은 논리적으로 비교할 수 없는 연산이기 때문에 NULL을 비교하는 연산자로 인해 전체조건이 거짓이 됨.
조건에 만족하는 값이 없으므로 SUM  결과는 NULL
in (1, 3, 5, null) -> 1 또는 3 또는 5 또는 null
not in (1, 3, 5, null) -> 1이 아닌 and 3이 아닌 and 5가 아닌 and null이 아닌(null이 들어가버리면 and 조건에서는 무조건 false)

==27번 2번 X== -> 3번
NATURAL JOIN은 USING, ON, WHERE절에서 조건 정의 불가
FULL OUTER JOIN = LEFT OUTER JOIN UNION RIGHT OUTER JOIN

==29번 1번 X== -> 4번
서브쿼리 조건절 - TAB1의 각 행의 COL1을 확인하여 같은 값을 갖는 행들 중 COL2의 최대값과 일치하는 행을 찾아 COL2의 총 합을 묻는 질의절.
COL1별 COL2 값이 최대인 행들의 COL2의 총 합을 리턴하는 문장.
A그룹에서는 30,30 B그룹에서는 40리턴 총 100

*상호 연관 쿼리*

==30번 1번 X== -> 2번
2번 제외 모든 지문은 기혼 40대 여성 중 구매이력이 있는 고객의 고객ID 출력
실제구매이력은 ORDERS에 있기 때문에 ORDERS의 CUSTOMER_ID 값에 존재하는지를 확인하여 구매자의 고객번호를 특정할 수 있음.
INNER JOINk IN, EXISTS 연산자로 구현 가능한데, 2번의 경우 인라인 뷰의 결과가 PROMOTION_ID가 1 이상인 상품을 구매한 고객 아이디만 특정하기 때문에 전체 상품 구매를 기준으로 출력하는 다른 보기와 결과값이 다르게 출력.

==31번 4번 X== -> 2번
셀프조인을 사용하여 EMP에서의 각 직원별로 입사일이 빠른 직원의 수 계산하는 질의절
LEFT OUTER JOIN을 수행하였기 때문에 입사일이 가장 빠른 SMITH의 경우도 CNT가 0으로 출력됨.

==32번 3번 X== -> 2번
1) 단일 행 서브쿼리는 단일 행 비교연산자인 =, <>, >, >=, <, <=의 연산자를 주로 사용
3) 메인쿼리에 값을 제공하기 위한 목적으로 사용하는 쿼리는 비연관 서브쿼리
4) 연관 서브쿼리는 일반적으로 메인쿼리가 먼저 수행된 후에 서브쿼리에서 조건이 맞는지 확인하고자 할 때 사용하기 때문에 항상 서브쿼리 조건이 만족하는지 확인하는 방식이라고 볼 수 없음. 

==39번 ? X== -> 1번
4 이길동 220 X (OFFSET)
3 최길동 200 X (OFFSET)
6 안길동 150 O
2 박길동 110 O
1 홍길동 100
5 구길동 80

==40번 4번 X== -> 3번
START WITH 조건이 1006과 1001이므로 두 행이 1레벨이 됨.
해당 행의 상위관리자코드를 사원번호로 갖는 행을 찾으면 둘 다 홍길동 출력

==44번 4번 X== -> 3번
[^0-9]+ 숫자가 아닌 값이 여러 개 반복되는 문자열 의미
REGEXP_SUBSTR은 이 패턴에 해당하는 값을 처음부터 찾아 단 하나의 문자열 추출

==45번 3번 X== -> 4번
COL4의 값은 문자상수이므로 날짜 변환 후 입력해야함.
DBMS의 기본 날짜 포맷이 'YYYY/MM/DD'가 아닌 경우는 이 문장은 에러 발생 

==47번 2번 X== -> 3번
1 A 10 null
2 B 20 null
3 C 30 null
4 D 40 null
5 E 50 AAA

NULL 삽입 이후 DEFAULT 값을 변경해도 이전에 삽입된 행은 반영되지 않고, 이후 삽입되는 행에 대해 적용.
COL3에 DEFAULT값이 설정되어 있다 하더라도 NULL을 직접 입력하면 NULL 삽입
COL3의 값이 아예 입력되지 않을 경우만 DEFAULT VALUE로 삽입

==48번 2번 X== -> 1번
CHAR, VARCHAR 타입일 경우 데이터가 있어도 서로 변경가능

==49번 1번 X== -> 2번
UNIQUE 제약조건에서는 NULL 허용

==50번 3번 X== -> 4번
중간관리자가 WITH GRANT OPTION으로 부여 받은 권한을 제 3자에게 부여한 경우, 관리자가 제 3자의 권한을 직접 회수할 수 없음.
중간관리자가 권한을 회수하면 제 3자에게 부여한 권한도 함께 회수됨.
반대로 WITH ADMIN OPTION으로 부여할 경우 중간관리자 권한 회수 시 제 3자에게 부여한 권한은 함께 회수되지 않음.
