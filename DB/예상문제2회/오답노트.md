==10번 4번 X== -> 1번
인조식별자를 사용하면 불필요하게 발생하는 중복데이터를 막을 수 있다. X
->  중복 데이터의 발생 가능성을 높이기 때문에 데이터 품질의 저하를 발생시킬 수 있는 단점을 가짐.

==11번 2번 X== -> 3번
FROM절에서 테이블 별칭을 선언한 경우는 반드시 테이블 별칭만으로 컬럼을 구분해야함.
-> TABLE1.COL2는 잘못된 표현.

==12번 1번 X== -> 4번
실행 순서 : from > where > group by > having > select > order by

==14번 2번 X== -> 4번
||(연결연산자)는 ORACLE에서의 문자열 결합 방식
SQL Server에서는 +를 사용하여 문자열을 결합 할 수 있음.
& 연산자로 문자열 결합은 불가.

==16번 3번 X== -> 1번
주민번호의 앞 6자리를 사용하여 날짜변환 시 RR 포맷을 사용하면 두 자리 연도가 1~49 사이면 2000년대, 50~99이면 1900년도의 4자리 연도로 출력
YY를 사용하면 2000년대를 출력

==20번 4번 X== -> 2번
NOT IN문의 서브쿼리 결과 중 NULL이 포함되는 경우 데이터가 출력되지 않음.
NULL은 논리적으로 비교할 수 없는 연산이기 때문에 NULL을 비교하는 연산자로 인해 전체조건이 거짓이 됨.
조건에 만족하는 값이 없으므로 SUM  결과는 NULL

==27번 2번 X== -> 3번
NATURAL JOIN은 USING, ON, WHERE절에서 조건 정의 불가

==29번 1번 X== -> 4번
서브쿼리 조건절 - TAB1의 각 행의 COL1을 확인하여 같은 값을 갖는 행들 중 COL2의 최대값과 일치하는 행을 찾아 COL2의 총 합을 묻는 질의절.
COL1별 COL2 값이 최대인 행들의 COL2의 총 합을 리턴하는 문장.
A그룹에서는 30,30 B그룹에서는 40리턴 총 100



==30번 1번 X==
==31번 4번 X==
==32번 3번 X==
==39번 ? X==
==40번 4번 X==
==44번 4번 X==
==45번 3번 X==
==47번 2번 X==
==48번 2번 X==
==49번 1번 X==
==50번 3번 X==