==10번 4번 X== -> 1번
인조식별자를 사용하면 불필요하게 발생하는 중복데이터를 막을 수 있다. X
->  중복 데이터의 발생 가능성을 높이기 때문에 데이터 품질의 저하를 발생시킬 수 있는 단점을 가짐.

==11번 2번 X== -> 3번
FROM절에서 테이블 별칭을 선언한 경우는 반드시 테이블 별칭만으로 컬럼을 구분해야함.
-> TABLE1.COL2는 잘못된 표현.

==12번 1번 X== -> 4번
실행 순서 : from > where > group by > having > select > order by

==14번 2번 X== -> 4번
||(연결연산자)는 ORACLE에서의 문자열 결합 방식
SQL Server에서는 +를 사용하여 문자열을 결합 할 수 있음.
& 연산자로 문자열 결합은 불가.

==16번 3번 X== -> 1번
주민번호의 앞 6자리를 사용하여 날짜변환 시 RR 포맷을 사용하면 두 자리 연도가 1~49 사이면 2000년대, 50~99이면 1900년도의 4자리 연도로 출력
YY를 사용하면 2000년대를 출력

==20번 4번 X== -> 2번
NOT IN문의 서브쿼리 결과 중 NULL이 포함되는 경우 데이터가 출력되지 않음.
NULL은 논리적으로 비교할 수 없는 연산이기 때문에 NULL을 비교하는 연산자로 인해 전체조건이 거짓이 됨.
조건에 만족하는 값이 없으므로 SUM  결과는 NULL

==27번 2번 X== -> 3번
NATURAL JOIN은 USING, ON, WHERE절에서 조건 정의 불가

==29번 1번 X== -> 4번
서브쿼리 조건절 - TAB1의 각 행의 COL1을 확인하여 같은 값을 갖는 행들 중 COL2의 최대값과 일치하는 행을 찾아 COL2의 총 합을 묻는 질의절.
COL1별 COL2 값이 최대인 행들의 COL2의 총 합을 리턴하는 문장.
A그룹에서는 30,30 B그룹에서는 40리턴 총 100

==30번 1번 X== -> 2번
2번 제외 모든 지문은 기혼 40대 여성 중 구매이력이 있는 고객의 고객ID 출력
실제구매이력은 ORDERS에 있기 때문에 ORDERS의 CUSTOMER_ID 값에 존재하는지를 확인하여 구매자의 고객번호를 특정할 수 있음.
INNER JOINk IN, EXISTS 연산자로 구현 가능한데, 2번의 경우 인라인 뷰의 결과가 PROMOTION_ID가 1 이상인 상품을 구매한 고객 아이디만 특정하기 때문에 전체 상품 구매를 기준으로 출력하는 다른 보기와 결과값이 다르게 출력.

==31번 4번 X== -> 2번
셀프조인을 사용하여 EMP에서의 각 직원별로 입사일이 빠른 직원의 수 계산하는 질의절
LEFT OUTER JOIN을 수행하였기 때문에 입사일이 가장 빠른 SMITH의 경우도 CNT가 0으로 출력됨.

==32번 3번 X== -> 2번
1) 단일 행 서브쿼리는 단일 행 비교연산자인 =, <>, >, >=, <, <=의 연산자를 주로 사용
3) 메인쿼리에 값을 제공하기 위한 목적으로 사용하는 쿼리는 비연관 서브쿼리
4) 연관 서브쿼리는 일반적으로 메인쿼리가 먼저 수행된 후에 서브쿼리에서 조건이 맞는지 확인하고자 할 때 사용하기 때문에 항상 서브쿼리 조건이 만족하는지 확인하는 방식이라고 볼 수 없음. 

==39번 ? X== -> 1번
4 이길동 220 X (OFFSET)
3 최길동 200 X (OFFSET)
6 안길동 150 O
2 박길동 110 O
1 홍길동 100
5 구길동 80

==40번 4번 X== -> 3번


==44번 4번 X==
==45번 3번 X==
==47번 2번 X==
==48번 2번 X==
==49번 1번 X==
==50번 3번 X==