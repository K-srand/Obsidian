3번 
속성의 특성에 따른 분류
기본 속성, 파생 속성, 설계 속성

*속성분류 다시 학습*

엔터티 구성 방식에 따른 분류
PK, FK, 일반속성

11번
FROM절은 ORACLE에서는 생략 불가.
GROUP BY 절과 HAVING 절은 순서가 바뀌어도 상관없으나 가급적 순서대로 사용한다.

*HAVING, FROM 절 다시 학습*

14번
LPAD(대상, n, 문자열) -> 대상 왼쪽에 문자열을 추가하여 총 n의 길이 리턴

*문자함수 종류 다시 학습*

16번
NVL(대상, 치환값), ISNULL(대상, 치환값) -> 대상이 널이면 치환값 리턴
COALESCE(대상1, 대상2, ..., 그외리턴) -> 대상들 중 널이 아닌값 출력, 모두 널이면 그외리턴값 리턴됨.
NULLIF(대상1, 대상2) -> 두 값이 같으면 널 리턴, 다르면 대상1 리턴

*일반함수 종류 다시 학습*

17번
SIGN(SAL-4000), 1, 1, 0 -> SAL>4000이면 SAL-4000은 양수이므로 SIGN을 취한 값이 1이 리턴됨.
DECODE문 해석하면 SAL이 4000보다 큰 경우 1을, 그렇지 않은 경우 0을 리턴

*DECODE, SIGN문 다시 학습*

18번
CASE문 축약형 문법은 반드시 비교 대상과 비교 상수의 데이터 타입이 일치해야함.
SUBSTR 결과는 항상 문자로 출력되므로 숫자 상수와 비교 시 에러 발생.

*SUBSTR, CASE문 다시 학습*

20번
1) CASE문에 의해 10번 부서원의 경우 1, 그 외 부서원들은 0 생성 -> 이를 모두 count 하면 1과 0을 모두 세므로 10번 부서원만 셀 수 없음.
2) ELSE를 생략하여 조건에 맞지 않는 값을 NULL로 리턴한다면 NULL은 count하지 않으므로 조건에 맞는 대상만 셀 수 있음.
3) SUM의 경우는 조건에 맞을 경우 1, 그렇지 않을 경우 0으로 출력하면 조건에 맞는 대상의 개수를 구할 수 있음.
4) 

23번
1) (200+300) + (100+400) = 1000
2) (NULL) + (100) = NULL
3) (300) + (100) = 400
4) (200) + (400) = 600

*NULL 다시 학습*

27번
TO_CHAR에 의해 SAL 값이 문자로 변환되며, 문자 값의 대소 비교는 값의 왼쪽부터 비교하므로 왼쪽값이 가장 작은 값의 크기가 제일 작다.
-> 1300 < 2500 < 300 < 800

29번
TAB1을 RULE_NAME에 매핑되는 규칙으로 TAB2에 조인을 수행했기 때문에, 각 행마다 LIKE 조건이 일치하면 TAB2 값이 출력됨.
-> SCOTT, FORD, FORD (총 행의 수 3건)

31번
1) NULL은 IN 연산자에 의해 출력되지 않기 때문에 V1이 A, B인 경우만 리턴
2) NOT IN 연산자는 서브쿼리 결과에 NULL이 포함될 경우 전체가 거짓이 되므로 아무것도 출력되지 않음.
3) 