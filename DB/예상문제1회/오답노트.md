3번 
속성의 특성에 따른 분류
기본 속성, 파생 속성, 설계 속성

*속성분류 다시 학습*

엔터티 구성 방식에 따른 분류
PK, FK, 일반속성

11번
FROM절은 ORACLE에서는 생략 불가.
GROUP BY 절과 HAVING 절은 순서가 바뀌어도 상관없으나 가급적 순서대로 사용한다.

*HAVING, FROM 절 다시 학습*

14번
LPAD(대상, n, 문자열) -> 대상 왼쪽에 문자열을 추가하여 총 n의 길이 리턴

*문자함수 종류 다시 학습*

16번
NVL(대상, 치환값), ISNULL(대상, 치환값) -> 대상이 널이면 치환값 리턴
COALESCE(대상1, 대상2, ..., 그외리턴) -> 대상들 중 널이 아닌값 출력, 모두 널이면 그외리턴값 리턴됨.
NULLIF(대상1, 대상2) -> 두 값이 같으면 널 리턴, 다르면 대상1 리턴

*일반함수 종류 다시 학습*

17번
SIGN(SAL-4000), 1, 1, 0 -> SAL>4000이면 SAL-4000은 양수이므로 SIGN을 취한 값이 1이 리턴됨.
DECODE문 해석하면 SAL이 4000보다 큰 경우 1을, 그렇지 않은 경우 0을 리턴

*DECODE, SIGN문 다시 학습*

18번
CASE문 축약형 문법은 반드시 비교 대상과 비교 상수의 데이터 타입이 일치해야함.
SUBSTR 결과는 항상 문자로 출력되므로 숫자 상수와 비교 시 에러 발생.

*SUBSTR, CASE문 다시 학습*

20번
1) CASE문에 의해 10번 부서원의 경우 1, 그 외 부서원들은 0 생성 -> 이를 모두 count 하면 1과 0을 모두 세므로 10번 부서원만 셀 수 없음.
2) ELSE를 생략하여 조건에 맞지 않는 값을 NULL로 리턴한다면 NULL은 count하지 않으므로 조건에 맞는 대상만 셀 수 있음.
3) SUM의 경우는 조건에 맞을 경우 1, 그렇지 않을 경우 0으로 출력하면 조건에 맞는 대상의 개수를 구할 수 있음.
4) 