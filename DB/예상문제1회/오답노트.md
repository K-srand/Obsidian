3번 
속성의 특성에 따른 분류
기본 속성, 파생 속성, 설계 속성

*속성분류 다시 학습*

엔터티 구성 방식에 따른 분류
PK, FK, 일반속성

11번
FROM절은 ORACLE에서는 생략 불가.
GROUP BY 절과 HAVING 절은 순서가 바뀌어도 상관없으나 가급적 순서대로 사용한다.

*HAVING, FROM 절 다시 학습*

14번
LPAD(대상, n, 문자열) -> 대상 왼쪽에 문자열을 추가하여 총 n의 길이 리턴

*문자함수 종류 다시 학습*

16번
NVL(대상, 치환값), ISNULL(대상, 치환값) -> 대상이 널이면 치환값 리턴
COALESCE(대상1, 대상2, ..., 그외리턴) -> 대상들 중 널이 아닌값 출력, 모두 널이면 그외리턴값 리턴됨.
NULLIF(대상1, 대상2) -> 두 값이 같으면 널 리턴, 다르면 대상1 리턴

*일반함수 종류 다시 학습*

17번
SIGN(SAL-4000), 1, 1, 0 -> SAL>4000이면 SAL-4000은 양수이므로 SIGN을 취한 값이 1이 리턴됨.
DECODE문 해석하면 SAL이 4000보다 큰 경우 1을, 그렇지 않은 경우 0을 리턴

*DECODE, SIGN문 다시 학습*

18번
CASE문 축약형 문법은 반드시 비교 대상과 비교 상수의 데이터 타입이 일치해야함.
SUBSTR 결과는 항상 문자로 출력되므로 숫자 상수와 비교 시 에러 발생.

*SUBSTR, CASE문 다시 학습*

20번
1) CASE문에 의해 10번 부서원의 경우 1, 그 외 부서원들은 0 생성 -> 이를 모두 count 하면 1과 0을 모두 세므로 10번 부서원만 셀 수 없음.
2) ELSE를 생략하여 조건에 맞지 않는 값을 NULL로 리턴한다면 NULL은 count하지 않으므로 조건에 맞는 대상만 셀 수 있음.
3) SUM의 경우는 조건에 맞을 경우 1, 그렇지 않을 경우 0으로 출력하면 조건에 맞는 대상의 개수를 구할 수 있음.
4) 

23번
1) (200+300) + (100+400) = 1000
2) (NULL) + (100) = NULL
3) (300) + (100) = 400
4) (200) + (400) = 600

*NULL 다시 학습*

27번
TO_CHAR에 의해 SAL 값이 문자로 변환되며, 문자 값의 대소 비교는 값의 왼쪽부터 비교하므로 왼쪽값이 가장 작은 값의 크기가 제일 작다.
-> 1300 < 2500 < 300 < 800

29번
TAB1을 RULE_NAME에 매핑되는 규칙으로 TAB2에 조인을 수행했기 때문에, 각 행마다 LIKE 조건이 일치하면 TAB2 값이 출력됨.
-> SCOTT, FORD, FORD (총 행의 수 3건)

31번
1) NULL은 IN 연산자에 의해 출력되지 않기 때문에 V1이 A, B인 경우만 리턴.
2) NOT IN 연산자는 서브쿼리 결과에 NULL이 포함될 경우 전체가 거짓이 되므로 아무것도 출력되지 않음.
3) EXISTS 연산자는 서브쿼리 결과가 참이면 메인 쿼리 결과 리턴.
   A.V1=B.V1 만족하면 TAB1 결과가 출력되어 V1이 A, B인 행 선택됨.
4) NOT EXISTS 연산자는 반대로 서브쿼리 결과가 거짓이면 출력됨.
   -> NULL끼리 같은 조건은 항상 거짓이므로 TAB1의 V1이 NULL인 경우와 C가 최종 리턴됨.

32번
2020년 2월 1일보다 입사일이 큰 행의 DEPTNO(30, 40, 50)가 출력되고 ALL이 작다와 결합되어 이들 중 30보다 작거나 같은 조건으로 전달됨.
-> DEPTNO가 10, 20, 30인 EMPNO의 수 총 3개

33번
스칼라 서브쿼리가 여러 행인 경우 출력 불가.
메인 쿼리 절에 사용된 WHERE A.NO = B.NO 조건은 실행 불가
-> 메인 쿼리에서는 FROM절에 A 테이블만 선언되었기 때문에 B 테이블은 인식할 수 없음.

*서브쿼리 다시 학습*

35번
고객-서비스 구매
고객 : 필수 관계
서비스 : 선택적 관계
-> LEFT OUTER JOIN 시 서비스 구매를 하지 않은 고객의 서비스 구매 정보가 NULL로 출력됨.
고객의 성별로 서비스 구매나 서비스 테이블의 컬럼을 count할 경우 NULL은 세지 않기 때문에 정상적으로 구매를 한 고객 수가 리턴될 때 2번의 경우 고객 테이블의 고객 번호를 세기 때문에 성별 고객 수가 출력됨.

36번
DEPTNO와 DEPARTMENT_ID 컬럼의 데이터 유형이 다르기 때문에 에러 발생.

*집합연산자 다시 학습*

37번
ROLLUP(A, B) : A별, (A, B)별, 전체 그룹 연산 결과 출력
CUBE(A, B) : A별, B별, (A, B)별, 전체 그룹 연산 결과 출력
GROUPING SET : 나열한 것만 출력

38번
SUM의 경우 ORDER BY 사용 시 ORDER BY 컬럼 순서대로 누적 합 계산(범위는 RANGE가 기본)
RANGE는 ORDER BY 절에 명시된 컬럼의 값이 같을 경우 하나의 그룹으로 묶어서 누적 합 계산하는 범위
-> 2024.01.02 값이 두 개이므로 각각 1000과 2000이 먼저 3000으로 결합되어 두 번째와 세 번째 행의 누적 합이 둘 다 4000이 됨.
DENSE_RANK의 경우 동순위 발생 뒤 순위가 연속적으로 출력되므로 주문번호가 3인 행의 순위는 2위가 됨.

39번
기본 범위 RANGE UNBOUNDED PRECEDING AND CURRENT ROW
-> DNAME 내 SAL 순서대로 가장 앞에 있는 이름은 아시아지부의 경우 홍길동, 남유럽지부의 경우 김길동이 됨.
각 행마다 LAST_VALUE를 구할 때 범위가 처음부터 현재 행까지만 고려해서 마지막 값을 리턴하기 때문에 항상 현재 행의 값이 마지막 값이 되므로 각 행의 값 리턴.

40번


43번
44번
45번
48번
49번