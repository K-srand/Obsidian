강의 목록 페이지 로딩 시간 단축을 위한 페이지네이션



--------------------------------------------------------------------------

<h1> 무한스크롤 vs 페이지네이션 </h1>

### **무한스크롤(Infinite Scroll)**

사용자가 스크롤할 때마다 자동으로 콘텐츠를 로드하는 방식.

#### **장점**

- **끊김 없는 사용자 경험**: 사용자가 페이지 전환 없이 콘텐츠를 계속 탐색 가능.
- **몰입감 높은 UI**: 이미지나 동영상 콘텐츠와 같은 시각적 요소에 적합.
- **모바일 친화적**: 클릭 대신 스크롤 중심의 인터페이스는 모바일 기기에서 사용하기 편리함.

#### **단점**

- **하단 콘텐츠 접근 어려움**: 푸터나 중요한 하단 메뉴에 접근하기 어렵다.
- **정확한 위치 저장 어려움**: 콘텐츠를 탐색하다가 특정 위치로 돌아가야 하는 경우 번거로움.
- **SEO 비효율적**: 검색 엔진이 콘텐츠를 제대로 크롤링하지 못할 가능성이 있음.

#### **적합한 상황**

1. **소셜 미디어**: 피드 형태로 콘텐츠를 소비하는 Instagram, Twitter와 같은 플랫폼.
2. **이미지/동영상 플랫폼**: Pinterest, YouTube처럼 시각적 콘텐츠가 주된 서비스.
3. **사용자 탐색이 주요 목적**: 사용자가 끝까지 탐색하도록 유도하고 싶은 경우.




### **페이지네이션(Pagination)**

콘텐츠를 여러 페이지로 나누어 탐색하도록 하는 방식.

#### **장점**

- **콘텐츠 관리 용이**: 사용자가 현재 위치와 탐색 범위를 명확히 알 수 있음.
- **SEO 친화적**: 검색 엔진이 각각의 페이지를 독립적으로 크롤링 가능.
- **명확한 데이터 구조**: 사용자가 필요한 정보를 효율적으로 찾을 수 있음.

#### **단점**

- **끊김 발생**: 페이지 전환 시 로딩 시간이 발생해 사용자 경험이 중단될 수 있음.
- **탐색 제한**: 사용자가 여러 페이지를 탐색하려면 클릭을 반복해야 함.

#### **적합한 상황**

1. **검색 결과**: Google, 네이버 같은 검색 엔진.
2. **정리된 데이터**: 쇼핑몰, 도서관, 게시판 등 카테고리나 필터링이 중요한 경우.
3. **특정 정보 탐색**: 사용자가 특정 데이터를 찾는 것이 주요 목적일 때.


--------------------------------------------------------------------------

강의 목록 페이지의 경우 카테고리별 분류가 필요하고, 한번에 많은 데이터를 불러오는데 로딩 시간이 많이 걸린다.
이에 따라 페이지네이션을 구현하는 것이 purepoint에 더 적합하다고 판단하게 되었다.

--------------------------------------------------------------------------

<h1> 페이지네이션 구현 </h2>

1. Spring Data JPA PagingAndSortingRepository 이용


public interface ItemRepository extends PagingAndSortingRepository<Item, Long> {
}


@Service
public class ItemService {
    private final ItemRepository itemRepository;

    public ItemService(ItemRepository itemRepository) {
        this.itemRepository = itemRepository;
    }

    public Page<Item> getItems(int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("name").ascending());
        return itemRepository.findAll(pageable);
    }
}

@RestController
@RequestMapping("/items")
public class ItemController {
    private final ItemService itemService;

    public ItemController(ItemService itemService) {
        this.itemService = itemService;
    }

    @GetMapping
    public Page<Item> getItems(@RequestParam int page, @RequestParam int size) {
        return itemService.getItems(page, size);
    }
}

장점
- 구현이 간단하고, 기본적인 페이지네이션 및 정렬이 지원됨.
단점
- 복잡한 쿼리에는 추가적인 작업이 필요(MyBatis, QueryDSL 등 활용 가능)


2. Pageable을 사용한 페이징

@Repository
public interface ItemRepository extends JpaRepository<Item, Long> {
    Page<Item> findByCategory(String category, Pageable pageable);
}


@GetMapping("/category/{category}")
public Page<Item> getItemsByCategory(
        @PathVariable String category,
        @RequestParam int page,
        @RequestParam int size) {
    Pageable pageable = PageRequest.of(page, size);
    return itemRepository.findByCategory(category, pageable);
}


장점
- 쿼리에 조건을 추가해 유연한 페이지네이션 가능
단점
- 복잡한 비즈니스 로직이 필요한 경우 제한적


3. QueryDSL을 활용한 동적 페이지네이션

dependency 추가(2024-12-09 기준 최신버전)
implementation 'com.querydsl:querydsl-maven-plugin:5.1.0'

@Repository
public class ItemRepositoryCustomImpl implements ItemRepositoryCustom {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Page<Item> findItemsWithFilter(String filter, Pageable pageable) {
        QItem item = QItem.item;

        JPQLQuery<Item> query = new JPAQuery<>(entityManager);
        query.from(item)
             .where(item.name.contains(filter));

        long total = query.fetchCount();
        List<Item> items = query.offset(pageable.getOffset())
                                 .limit(pageable.getPageSize())
                                 .fetch();

        return new PageImpl<>(items, pageable, total);
    }
}

@GetMapping("/search")
public Page<Item> searchItems(@RequestParam String filter, Pageable pageable) {
    return itemRepository.findItemsWithFilter(filter, pageable);
}

장점
- 복잡한 조건을 동적으로 처리 가능
단점
- 설정과 코드 작성이 복잡


4. MyBatis와 페이지네이션 라이브러리 사용

implementation 'com.github.pagehelper:pagehelper-spring-boot-starter:2.1.0'

@Mapper
public interface ItemMapper {
    @Select("SELECT * FROM items WHERE category = #{category}")
    List<Item> findByCategory(String category);
}

public List<Item> getItemsByCategory(String category, int page, int size) {
    PageHelper.startPage(page, size);
    return itemMapper.findByCategory(category);
}


장점
- SQL 작성이 유연하고 제어가 쉬움
단점
- Spring Data JPA와 함께 사용하기는 다소 까다로움


5. 커스텀 구현

@Query(value = "SELECT * FROM items LIMIT :limit OFFSET :offset", nativeQuery = true)
List<Item> findItems(@Param("limit") int limit, @Param("offset") int offset);

@GetMapping("/custom")
public List<Item> getCustomPagination(@RequestParam int page, @RequestParam int size) {
    int offset = page * size;
    return itemRepository.findItems(size, offset);
}

장점
- 간단한 경우에 빠르게 구현 가능
단점
- 페이지네이션 처리와 관련된 부가 기능(정렬, 전체 개수 계산 등)은 수동으로 구현해야 함.

정리
- 단순한 페이지네이션 -> Spring Data JPA 활용
- 복잡한 조건/동적 쿼리 -> QueryDSL 사용
- SQL 기반 제어 -> MyBatis + PageHelper
- 직접 제어 -> Native Query로 간단한 페이지네이션 구현


