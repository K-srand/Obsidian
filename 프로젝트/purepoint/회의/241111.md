배치 + 스케줄러 방식
```
@Component
public class BatchScheduler {

    private final JobLauncher jobLauncher;
    private final Job job;

    public BatchScheduler(JobLauncher jobLauncher, Job job) {
        this.jobLauncher = jobLauncher;
        this.job = job;
    }

    @Scheduled(cron = "0 0 0 * * ?")
    public void runBatchJob() throws Exception {
        JobParameters jobParameters = new JobParametersBuilder()
                .addLong("time", System.currentTimeMillis())
                .toJobParameters();
        jobLauncher.run(job, jobParameters);
    }
}
```

Job 재실행
이미 수행된 job이 다시 실행되지 않을 수 있음.
job을 실행할 때마다 매번 실행되게 하려면, 이전에 job이 성공적으로 완료되었더라도 항상 새로운 실행을 트리거하도록 설정.

변경 전
```
@Override  
public void run(String... args) throws Exception {  
    jobLauncher.run(youtubeApiJob, new JobParameters());  
}
```

변경 후
```
@Override  
public void run(String... args) throws Exception {  
    try {  
        JobParameters jobParameters = new JobParametersBuilder()  
                .addLong("timestamp", System.currentTimeMillis())  
                .toJobParameters();  
  
        jobLauncher.run(youtubeApiJob, jobParameters);  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
}
```



itemprocessor에서 DB에 이미 존재하는 데이터는 넣지 않도록 하고 있으나 itemwriter에서 다시 한번 중복 여부를 확인하는 것을 권장

**VideoItemProcessor**
```
@Override  
public Video process(Video video) throws Exception {  
    if (videoRepository.existsById(video.getVideoId())) {  
        return null;  
    }  
    return video;  
}
```

**VideoItemWriter**
변경 전
```
@Override  
public void write(Chunk<? extends Video> videos) {  
    videoRepository.saveAll(videos);  
}
```

변경 후
```
@Override  
public void write(Chunk<? extends Video> videos) {  
    List<Video> newVideos = videos.getItems().stream()  
            .filter(video -> !videoRepository.existsById(video.getVideoId()))  
            .collect(Collectors.toList());  
  
    videoRepository.saveAll(newVideos);  
}
```





















고려할 사항
사용자에게 사라진 영상에 대해 어떠한 방식으로 알릴 것인지 생각해야한다.



